>@[toc]
###### 1. 算法的五大特性
① 输入: 算法具有0个或多个输入

② 输出: 算法至少有1个或多个输出

③ 有穷性: 算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成

④ 确定性：算法中的每一步都有确定的含义，不会出现二义性

⑤ 可行性：算法的每一步都是可行的，也就是说每一步都能够执行有限的次数完成
>**`算法是独立存在的一种解决问题的方法和思想。`**
###### 2. 最坏时间复杂度
① 算法完成工作最少需要多少基本操作，即最优时间复杂度

② 算法完成工作最多需要多少基本操作，即最坏时间复杂度

③ 算法完成工作平均需要多少基本操作，即平均时间复杂度

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**`最优时间复杂度`**，其价值不大，因为它没有提供什么有用信息，其反映的只是最乐观最理想的情况，没有参考价值；**`最坏时间复杂度	`**，提供了一种保证，表明算法在此种程度的基本操作中一定能完成工作。**`平均时间复杂度`**，是对算法的一个全面评价，因此它完整全面的反映了这个算法的性质。但另一方面，这种衡量并没有保证，不是每个计算都能在这个基本操作内完成。而且，对于平均情况的计算，也会因为应用算法的实例分布可能并不均匀而难以计算。
>**`我们主要关注算法的最坏情况，亦即最坏时间复杂度。`**
###### 3. 时间复杂度的基本计算规则
基本操作，即只有常数项，认为其时间复杂度为O(1)

顺序结构，时间复杂度按加法进行计算

循环结构，时间复杂度按乘法进行计算

分支结构，时间复杂度取最大值

>**`判断一个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略。在没有特殊说明时，我们所分析的算法的时间复杂度都是指最坏时间复杂度。`**
###### 4. 常见时间复杂度
| 执行次数函数举例 | 阶 | 非正式术语 |
|--|--|--|
| 12 | O(1) | 常数阶 |
| 2n+3 |O(n)  | 线性阶 |
| 3n2+2n+1 | O(n<sup>2</sup>) | 平方阶 |
| 5log2n+20 | O(logn) | 对数阶 |
| 2n+3nlog2n+19 | O(nlogn) | nlogn阶 |
| 6n3+2n2+3n+4 | O(n<sup>3</sup>) | 立方阶 |
| 2n | O(2n) | 指数阶 |
>**`经常将log2n（以2为底的对数）简写成logn。`**
###### 5. 常见时间复杂度之间的关系
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200525112117151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoYW5sb24=,size_16,color_FFFFFF,t_70)
**所消耗的时间从小到大：O(1) < O(logn) < O(n) < O(nlogn) < O(n<sup>2</sup>) < O(n<sup>2</sup>log(n)) < O(n<sup>3</sup>) < O(2n) < O(n!) < O(n<sup>n</sup>)**
###### 6. 算法分析
如果 a+b+c=1000，且 a^2+b^2=c^2（a,b,c 为自然数），如何求出所有a、b、c可能的组合?

① 第一种算法：
```py
import time

start_time = time.time()
for a in range(1001):
    for b in range(1001):
        for c in range(1001):
            if a ** 2 + b ** 2 == c ** 2 and a + b + c == 1000:
                print("a, b, c: %d, %d, %d" % (a, b, c))
end_time = time.time()
print('%d' % (end_time - start_time))
"""
a, b, c: 0, 500, 500
a, b, c: 200, 375, 425
a, b, c: 375, 200, 425
a, b, c: 500, 0, 500
576
"""
```
**时间复杂度：T(n) = O(n*n*n) = O(n3)**

② 第二种算法：
```py
import time

start_time = time.time()
for a in range(1001):
    for b in range(1001 - a):
        c = 1000 - a - b
        if a ** 2 + b ** 2 == c ** 2:
            print("a, b, c: %d, %d, %d" % (a, b, c))
end_time = time.time()
print(end_time - start_time)
"""
a, b, c: 0, 500, 500
a, b, c: 200, 375, 425
a, b, c: 375, 200, 425
a, b, c: 500, 0, 500
0.4090738296508789
"""
```
**时间复杂度：T(n) = O(n*n*(1+1)) = O(n*n) = O(n<sup>2</sup>)**
